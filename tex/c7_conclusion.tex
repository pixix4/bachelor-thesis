\chapter{Schluss}
\label{chap:conclusion}

In diesem Kapitel wird evaluiert in wie weit diese Arbeit die im \cref{chap:introduction} genannten Ziele erfüllt hat.
Zu diesem Zweck werden die Ergebnisse der Analyse und der Implementierung zusammengefasst und in das Feld der bestehenden Verfahren eingeordnet.
Dabei werden die Ergebnisse der einzelnen Teilschritte analysiert und benutzt, um das Klassifikationsschema aus \cref{chap:related_work} zu erweitern.
Abschließend wird ein Ausblick über mögliche Erweiterungen des vorgestellten Verfahrens und weiterführende Arbeiten auf dem Gebiet des Konsistenzvergleiches zwischen BPMN- und BROS-Modellen gegeben.

\section{Zusammenfassung}

Ziel der Arbeit war die Konsistenz zwischen BPMN- und BROS-Modellen zu untersuchen.
Dieses wurde erreicht indem eine Lösung des Konsistenzproblems für die beiden Modellarten erstellt wurde.
Als Einführung in BPMN und BROS wurden deren Konzepte und Metamodelle erläutert.
Um einen Einstieg in das Themengebiet der Konsistenzprüfung zu erhalten, wurden bestehende Verfahren zur Überprüfung der Konsistenz von UML-Modellen analysiert.
Dafür wurde ein Klassifikationsschema auf Basis des Schemas von \cite{Usman2008}) erstellt und zur Klassifizierung der Verfahren verwendet.

Mit Hilfe der erstellten Metamodelle und den Konsistenzverfahren für UML-Modelle wurden Konsistenzbedingungen zwischen BPMN- und BROS-Modellen erarbeitet.
Die sechs erstellten Regeln basieren auf dem direkten Vergleich der Modelle anhand ihrer Metamodelle.
Diese in Prolog formalisierten Regeln benötigen keine Zwischendarstellung und sind daher leicht erweiterbar.
Für die Automatisierung der Konsistenzprüfung wurde eine Referenzarchitektur erstellt, die die formalen Regeln ausführt.
Dieses zweistufige Verfahren baut zunächst eine Zuordnung von Elementen auf und überprüft anschließend die Modelle mit dem Regelsatz auf ihre Konsistenz.
Im nächsten Schritt wurde das Verfahren implementiert, um einerseits seine Funktionalität zu zeigen und andererseits die Automatisierbarkeit zu beweisen.
Das dabei erstellte Tool ist in Kotlin entwickelt wurden, um zusätzlich eine mögliche Anbindung an den BROS-Editor \emph{FRaMED.io} zu erleichtern.
Wie die Modelleditoren \emph{bpmn.io} und \emph{FRaMED.io} ist das Tool webbasiert um plattformübergreifend nutzbar zu sein.

Die Evaluation des Verfahrens teilt sich in zwei Abschnitte auf.
Zum einen wurde die Anwendbarkeit anhand von einem Beispielsystem getestet.
Dazu wurde das Beispiel einer Pizzabestellung aus der Arbeit von \cite{Schoen} verwendet.
In seiner Arbeit hat \cite{Schoen} sowohl ein BPMN- als auch ein BROS-Modell gegeben die zueinander konsistent sind.
Zum anderen wurde die Erweiterbarkeit und Modularität des Verfahrens und der Implementierung evaluiert, indem eine weitere Regel aus dem \cref{chap:consistency} zu dem Tool hinzugefügt wurde.

\section{Wissenschaftlicher Beitrag}

Das in dieser Arbeit vorgestellte Verfahren zur Lösung des Konsistenzproblems basiert auf der Überprüfung eines Regelsatz.
Diese Regeln nutzen die Graphstruktur die durch die Metamodelle aufgestellt werden, um den Konsistenzvergleich durchzuführen.
Damit gehört das Verfahren, nach dem Klassifikationsschema aus \cref{chap:related_work}, zu der Klasse der Verfahren ohne Zwischendarstellung.
Die Nutzung eines Regelsatzes entspricht der Konsistenzstrategie des Monitorings.
In \cref{tab:Klassifikationsschema_extended} ist die Einordnung diese Arbeit in das bestehende Feld von Konsistenzverfahren abgebildet.
Die größte Übereinstimmung hat das hier vorgestellte Verfahren mit dem Konsistenzverfahren nach \cite{Egyed2006}.
Beide Verfahren testen die Intra-Modell (horizontale) Konsistenz, sind automatisierbar und wurden bereits evaluiert.
Sie unterscheiden sich neben den unterstützten Modellarten hauptsächlich im Grad der Erweiterbarkeit.
Das Verfahren von \cite{Egyed2006} benutzt zum Konsistenzvergleich Regeln auf Basis von OCL.
Dies erschwert die Erweiterbarkeit um neue Modellarten ungemein.
Nur Modellarten die auch zu dem UML-Standard gehören, werden von der OCL und damit auch von dem Verfahren unterstützt.
Auch das hier genutzte Verfahren hat einen hohen Aufwand, wenn eine neue Modellart hinzugefügt wird.
Allerdings ist die Erweiterbarkeit um neue Regeln mit weniger Aufwand verbunden.
Da das Verfahren direkt auf dem Graphen der Metamodell-Instanz arbeitet, können beliebige Regeln leicht erstellt werden.
\cite{Egyed2006} Verfahren ist hingegen auf die Möglichkeiten der OCL beschränkt, was die Erstellung einer neuen Regel erschweren könnte.

\begin{table}
  \begin{threeparttable}
    \centering
    \begin{tabular}{p{1.58cm} p{1.50cm} p{0.95cm} p{2.2cm} p{1.60cm} p{0.33cm}
        p{0.33cm} p{0.33cm} p{0.72cm} p{0.72cm}}
      &
      \rot{Diagrams} &
      \rot{Consistency} \rot{Type} &
      \rot{Consistency} \rot{Strategy} & 
      \rot{Intermediate} \rot{Representation} & 
      \rot{Case Study} & 
      \rot{Automatable} & 
      \rot{Tool Support} & 
      \rot{Model} \rot{Extensibility} & 
      \rot{Rule} \rot{Extensibility} \\
      \toprule
      Rasch 2003    & CD, SM              & Intra            & Monitoring           & CSP/OZ                      & \f{1}      & \f{H}       & \f{0}        & \f{H}               & \f{M}              \\
      \midrule
      Shinkawa 2006 & UCD, CD, SD, AD, SC & Inter            & Analysis             & CPN                         & \f{0}      & \f{H}       & \f{0}        & \f{M}               & \f{L}              \\
      \midrule
      Mens 2005     & CD, SD, SC          & All              & Monitoring           & Extended UML                & \f{1}      & \f{H}       & \f{1}        & \f{H}               & \f{M}              \\
      \midrule
      Egyed 2001    & CD, OD, SD          & Intra, Inter     & Construction         &                             & \f{0}      & \f{H}       & $\sim$       & \f{M}               & \f{M}              \\
      \midrule
      Egyed 2006    & CD, SD, SC          & Intra            & Monitoring           &                             & \f{1}      & \f{H}       & \f{1}        & \f{L}               & \f{M}              \\
      \midrule
      BROS          & BPMN, BROS          & Intra            & Monitoring           &                             & \f{1}      & \f{H}       & \f{1}        & \f{L}               & \f{H}  
    \end{tabular}
    \begin{tablenotes}
      \item \hfil
      \f{H}$ = $mit geringem Aufwand;
      \f{M}$ = $mit mittlerem Aufwand;
      \f{L}$ = $mit hohem Aufwand;
      \item \hfil
      \f{1}$ = $ja;
      \f{0}$ = $nein;
      $\sim$$ = $teilweise
    \end{tablenotes}    
  \end{threeparttable}
  \caption{Einordnung des neuen Verfahrens}%
  \label{tab:Klassifikationsschema_extended}
\end{table}

Diese Erweiterbarkeit wurde mit Hilfe der Implementierung nachgewiesen.
Ziel der Implementierung war, den Konsistenzvergleich zu automatisieren und gleichzeitig die Modularität und damit auch Erweiterbarkeit des Verfahrens zu gewährleisten.
Dies wurde mit der Aufteilung der Konsistenzbedingungen in einzelne Regeln erreicht.
Jede dieser Regeln besteht aus einem, teilweise auch mehreren Modulen, die sich unabhängig voneinander aktivieren und ergänzen lassen.
Die Automatisierbarkeit wurde mit der Implementierung gezeigt und anhand eines Beispieles zusätzlich evaluiert.
Dabei konnte ein fehlerhaftes BROS-Modell erfolgreich korrigiert werden.
Da das genutzte Beispiel auf der Arbeit von \cite{Schoen} basiert, konnte diese zur Verifizierung der Korrektheit der Konsistenz genutzt werden.

\section{Zukünftige Arbeiten}

Wie in \cref{chap:evaluation} beschrieben, muss ein von dem Tool gefundener Konsistenzfehler, nicht unbedingt ein echter Konsistenzfehler sein.
Dieser Fehler kann auch von dem Modellierer beabsichtigt sein und eine gewollte Erweiterung des Modelles darstellen.
Momentan kann das Tool nicht mit diesem Problem umgehen.
Eine Möglichkeit bestimmt Fehler zu ignorieren oder als gewollt zu kennzeichnen, wäre eine sinnvolle Erweiterung für das implementierte Tool.

Um die allgemeine Funktionalität zu verbessern, ist es erforderlich die Konsistenzbeziehungen zwischen BPMN- und BROS-Modellen genauer zu untersuchen.
In dieser Arbeit wurden nur sechs Konsistenzregeln vorgestellt, die die wichtigsten Bereiche der Konsistenz abdecken.
So sind noch keine Konsistenzbedingungen für z. B. BROS-Compartments oder BPMN-SubProcesses definiert.
Die Konsistenzregeln die zwischen diesen und weiteren Elementen gelten, müssen dafür noch analysiert werden.
Solange eine Formalisierung dieser Regeln auf Basis der Metamodelle möglich ist, können sie der bestehenden Implementierung hinzugefügt werden.

Neben der Erweiterung um neue Regeln, kann auch die Erweiterung um die syntaktische und semantische Konsistenzprüfung der Einzelmodelle untersucht werden.
Momentan ist diese Aufgabe abhängig von dem Modellierer.
Zwar existieren schon Verfahren und automatisierte Tools für diesen Konsistenzvergleich, allerdings sind sie nicht kompatibel mit der aktuellen Implementierung.
Auch müsste untersucht werden, ob dieser Konsistenzvergleich in einem zufriedenstellenden Funktionsumfang integrierbar ist.
Externe Programme die diese Funktionalität bereits besitzen, sind zumeist Editoren für diese Modelle.
Diese sind darauf spezialisiert diese Art von Konsistenzprüfung durchzuführen.
Eine eigene Implementierung hat die Gefahr einer schlechteren Erkennungsrate.

Eine weitere mögliche Erweiterung des Tools wäre die Integration in den bestehenden BROS-Editor \emph{FRaMED.io}.
Da BROS-Modelle auf den BPMN-Modellen aufbauen und teilweise wiederverwenden können, kann eine Integration den Entwicklungsprozess eines BROS-Modelles zu einem BPMN-Modell erheblich vereinfachen.
So könnte das BPMN-Modell direkt in den Editor geladen werden.
Dies würde dem Modellierer verschiedene Möglichkeiten geben.
Zum einen könnten Fehlermeldungen direkt graphisch in dem BROS-Modell markiert werden.
Damit könnten sich Fehler leichter finden und verstehen lassen.
Zum anderen könnten Teile des BROS-Modelles anhand des BPMN-Modelles autogeneriert werden.
Dies würde dem Modellierer vorallem bei großen Prozessen viel Zeit sparen.
Da die Referenzimplementierung, wie auch der BROS-Editor, in Kotlin entwickelt wurden, sind sie bereits technisch kompatibel.
Allerdings müsste noch evaluiert werden, wie das Ergebnis der Analyse in die graphische Darstellung integriert werden kann.
Sollte eine Autogenerierung implementiert werden, müsste zusätzlich noch analysiert werden, in wieweit dies möglich ist und wie nutzbar ein solches Modell gegenüber einem manuell erstelltem Modell wäre.
